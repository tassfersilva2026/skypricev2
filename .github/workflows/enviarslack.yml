name: enviarslack

on:
  schedule:
    - cron: "*/30 * * * *"   # a cada 30 min
  workflow_dispatch:

permissions:
  contents: read

env:
  TZ: America/Sao_Paulo

jobs:
  send:
    runs-on: ubuntu-latest
    concurrency:
      group: enviarslack
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install slack_sdk Pillow google-api-python-client google-auth google-auth-httplib2 tzdata

      - name: Ensure folders
        run: |
          mkdir -p state scripts

      - name: Create slack_send_drive_pairs.py
        shell: bash
        run: |
          cat > scripts/slack_send_drive_pairs.py <<'PY'
          # -*- coding: utf-8 -*-
          import os, sys, io, json, re
          from pathlib import Path
          from typing import Dict, Any, List
          from zoneinfo import ZoneInfo
          from slack_sdk import WebClient
          from slack_sdk.errors import SlackApiError
          from google.oauth2.service_account import Credentials
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaIoBaseDownload
          from PIL import Image
          from datetime import datetime, timezone

          SLACK_TOKEN   = os.environ.get("SLACK_TOKEN")
          SLACK_CHANNEL = os.environ.get("SLACK_CHANNEL")
          PNG_FOLDER_ID = os.environ.get("PNG_FOLDER_ID")
          PDF_FOLDER_ID = os.environ.get("PDF_FOLDER_ID")
          CUTOVER_SP    = os.environ.get("CUTOVER_SP")
          TZ_NAME       = os.environ.get("TZ_NAME", "America/Sao_Paulo")
          MAX_UPLOAD_MB = float(os.environ.get("MAX_UPLOAD_MB", "100"))

          for k, v in [("SLACK_TOKEN", SLACK_TOKEN), ("SLACK_CHANNEL", SLACK_CHANNEL),
                       ("PNG_FOLDER_ID", PNG_FOLDER_ID), ("PDF_FOLDER_ID", PDF_FOLDER_ID)]:
              if not v:
                  print(f"ERRO: defina {k} via secrets/env.", file=sys.stderr); sys.exit(1)

          STATE_FILE = Path("state/slack_sent_pairs.json")
          STATE_FILE.parent.mkdir(parents=True, exist_ok=True)

          SCOPES = ["https://www.googleapis.com/auth/drive.readonly"]
          creds = Credentials.from_service_account_file("sa.json", scopes=SCOPES)
          drive = build("drive", "v3", credentials=creds, cache_discovery=False)
          slack = WebClient(token=SLACK_TOKEN)

          def safe_name(name: str) -> str:
              return re.sub(r'[\\/:*?"<>|]+', "_", name)

          def to_utc_from_sp(local_str: str, tz_name: str) -> str:
              tz = ZoneInfo(tz_name)
              fmt = "%Y-%m-%dT%H:%M:%S" if "T" in local_str else "%Y-%m-%d %H:%M:%S"
              dt = datetime.strptime(local_str, fmt).replace(tzinfo=tz).astimezone(timezone.utc)
              return dt.strftime("%Y-%m-%dT%H:%M:%S") + "Z"

          def load_state() -> Dict[str, Any]:
              if STATE_FILE.exists():
                  try: return json.loads(STATE_FILE.read_text(encoding="utf-8"))
                  except: pass
              return {"pdf_sent_ids": [], "png_pair_keys": []}

          def save_state(s: Dict[str, Any]) -> None:
              STATE_FILE.write_text(json.dumps(s, ensure_ascii=False, indent=2), encoding="utf-8")

          def list_files(folder_id: str, cut_utc: str | None, mime_filter: str | None = None) -> List[Dict[str, Any]]:
              q = f"'{folder_id}' in parents and trashed=false"
              if cut_utc: q += f" and createdTime >= '{cut_utc}'"
              if mime_filter: q += f" and mimeType='{mime_filter}'"
              fields = "nextPageToken, files(id,name,mimeType,size,createdTime,modifiedTime)"
              out, token = [], None
              while True:
                  resp = drive.files().list(
                      q=q, fields=fields, orderBy="createdTime",
                      pageSize=100, pageToken=token,
                      includeItemsFromAllDrives=True, supportsAllDrives=True
                  ).execute()
                  out.extend(resp.get("files", []))
                  token = resp.get("nextPageToken")
                  if not token: break
              return out

          def fetch_bytes(file: Dict[str, Any]) -> tuple[bytes, str]:
              fid, name = file["id"], safe_name(file["name"])
              req = drive.files().get_media(fileId=fid)
              buf = io.BytesIO()
              dl = MediaIoBaseDownload(buf, req)
              done = Fals
